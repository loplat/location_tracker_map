<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏúÑÏπò Ï∂îÏ†Å ÏßÄÎèÑ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.1.0/leaflet.polylineDecorator.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ÎÑ§Ïù¥Î≤Ñ ÏßÄÎèÑ API (Ï£ºÏùò: YOUR_CLIENT_IDÎ•º Ïã§Ï†ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ IDÎ°ú Î≥ÄÍ≤ΩÌï¥Ïïº Ìï©ÎãàÎã§) -->
    <script type="text/javascript" src="https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=[YOUR_CLIENT_ID_HERE]"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .file-input-group, .url-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .file-input-group label, .url-input-group label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.9rem;
        }

        input[type="file"], input[type="url"] {
            padding: 12px;
            border: 2px solid #e0e6ed;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        input[type="file"]:focus, input[type="url"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .load-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .load-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }

        .map-container {
            flex: 1;
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .column-selector {
            margin-bottom: 15px;
        }

        .column-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            transition: border-color 0.3s ease;
        }

        .column-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .toggle-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        .tab-controls {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e6ed;
        }

        .tab-btn {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-weight: 600;
            color: #5f7d95;
            position: relative;
            transition: color 0.3s ease;
        }

        .tab-btn.active {
            color: #667eea;
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sheet-controls, .group-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }

        .checkbox-item:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
            transform: scale(1.1);
        }

        .checkbox-item label {
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
        }

        .status {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
            font-size: 13px;
            color: #6c757d;
            border: 1px solid #e9ecef;
        }

        .info-popup {
            font-family: inherit;
            max-width: 300px;
        }

        .info-popup h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 14px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .detail-row .label {
            font-weight: 600;
            color: #555;
            min-width: 80px;
        }

        .detail-row .value {
            color: #333;
            text-align: right;
            word-break: break-all;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .controls {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                flex-direction: row;
                overflow-x: auto;
            }
            
            .control-panel {
                min-width: 280px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è ÏúÑÏπò Ï∂îÏ†Å ÏßÄÎèÑ</h1>
            <div class="controls">
                <div class="file-input-group">
                    <label for="csvFile">üìÅ CSV/XLSX ÌååÏùº ÏóÖÎ°úÎìú</label>
                    <input type="file" id="csvFile" accept=".csv,.xlsx,.xls">
                </div>
                <div class="url-input-group">
                    <label for="sheetUrl">üîó Íµ¨Í∏Ä Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ URL</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="url" id="sheetUrl" placeholder="https://docs.google.com/spreadsheets/d/...">
                        <button class="load-btn" id="loadFromUrl">Î°úÎìú</button>
                    </div>
                </div>
            </div>
            <div class="status" id="status">ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò URLÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî</div>
        </div>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
            </div>

            <div class="sidebar">
                <div class="control-panel">
                    <h3>‚öôÔ∏è ÌëúÏãú ÏÑ§Ï†ï</h3>

                    <div class="toggle-section">
                        <span>ÎÑ§Ïù¥Î≤Ñ ÏßÄÎèÑ ÏÇ¨Ïö©</span>
                        <div class="toggle-switch" id="mapProviderToggle"></div>
                    </div>
                    
                    <div class="toggle-section">
                        <span>Í≤ΩÎ°ú ÌëúÏãú</span>
                        <div class="toggle-switch active" id="pathToggle"></div>
                    </div>

                    <div class="column-selector">
                        <label for="groupColumn">üè∑Ô∏è Í∑∏Î£π Í∏∞Ï§Ä Ïª¨Îüº:</label>
                        <select id="groupColumn">
                            <option value="">ÏóÜÏùå</option>
                        </select>
                    </div>

                    <div class="tab-controls">
                        <button class="tab-btn active" data-tab="sheets">üìä ÏãúÌä∏</button>
                        <button class="tab-btn" data-tab="groups">üè∑Ô∏è Í∑∏Î£π</button>
                    </div>

                    <div id="sheetControls" class="tab-content active"></div>
                    <div id="groupControls" class="tab-content"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let map;
        let naverMap;
        let mapProvider = 'osm'; // 'osm' or 'naver'
        let allData = {};
        let mapLayers = {};
        let pathLayers = {};
        let colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD', '#FF7675', '#74B9FF', '#A29BFE', '#6C5CE7', '#00B894', '#00CEC9', '#E84393', '#FD79A8'];
        let currentPopup = null;
        let showPaths = true;
        let currentGroupColumn = '';
        let allColumns = [];
        let activeTab = 'sheets';
        let selectedSheets = new Set();
        let selectedGroups = new Set();

        function isEmptyRow(row) { return !row || row.every(cell => !cell || cell.toString().trim() === ''); }

        // ÏßÄÎèÑ Ï¥àÍ∏∞Ìôî
        function initMap() {
            if (map) {
                map.remove();
                map = null;
            }
            if (naverMap) {
                naverMap.destroy();
                naverMap = null;
            }

            if (mapProvider === 'osm') {
                initLeafletMap();
            } else {
                initNaverMap();
            }
        }

        function initLeafletMap() {
            map = L.map('map').setView([37.5665, 126.9780], 11);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            map.on('click', clearPopup);
        }

        function initNaverMap() {
            const mapOptions = {
                center: new naver.maps.LatLng(37.5665, 126.9780),
                zoom: 11
            };
            naverMap = new naver.maps.Map('map', mapOptions);
        }

        // Í±∞Î¶¨ Í≥ÑÏÇ∞ Ìï®Ïàò (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // ÏßÄÍµ¨ Î∞òÏßÄÎ¶Ñ (km)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // ÏãúÍ∞Ñ Ï∞®Ïù¥ Í≥ÑÏÇ∞ Ìï®Ïàò
        function calculateTimeDiff(time1, time2) {
            const diff = Math.abs(new Date(time2) - new Date(time1));
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            return hours > 0 ? `${hours}ÏãúÍ∞Ñ ${minutes}Î∂Ñ` : `${minutes}Î∂Ñ`;
        }

        // ÌåùÏóÖ Ï†úÍ±∞ Ìï®Ïàò
        function clearPopup() {
            if (currentPopup) {
                if (mapProvider === 'osm') {
                    map.closePopup(currentPopup);
                } else {
                    currentPopup.close();
                }
                currentPopup = null;
            }
        }

        // ÏßÄÎèÑ API Ïñ¥ÎåëÌÑ∞
        function getMapApi() {
            const leafletApi = {
                createMarker: (location, color, groupName) => {
                    const marker = L.circleMarker([location.lat, location.lng], { radius: 8, fillColor: color, color: '#fff', weight: 2, opacity: 1, fillOpacity: 0.8 });
                    marker.on('mouseover', function(e) {
                        clearPopup();
                        const detailsHtml = location.headers.map((header, idx) => 
                            (location.rawData[idx] && location.rawData[idx].toString().trim()) ? `<div class="detail-row"><span class="label">${header}:</span><span class="value">${location.rawData[idx]}</span></div>` : ''
                        ).join('');
                        const popupContent = `<div class="info-popup"><h4>üìç ÏúÑÏπò Ï†ïÎ≥¥ (Row ${location.rowIndex})</h4>${detailsHtml}<div class="detail-row"><span class="label">Í∑∏Î£π:</span><span class="value">${groupName}</span></div></div>`;
                        currentPopup = L.popup({ closeButton: false, className: 'info-popup' }).setLatLng(e.latlng).setContent(popupContent).openOn(map);
                    });
                    marker.on('mouseout', clearPopup);
                    return marker;
                },
                createPath: (locations, color) => {
                    const pathCoords = locations.map(loc => [loc.lat, loc.lng]);
                    const polyline = L.polyline(pathCoords, { color: color, weight: 4, opacity: 0.8 });
                    
                    const decorator = L.polylineDecorator(polyline, {
                        patterns: [{
                            offset: 25, 
                            repeat: 100, 
                            symbol: L.Symbol.arrowHead({
                                pixelSize: 12, 
                                polygon: false,
                                pathOptions: { stroke: true, weight: 2, color: color }
                            })
                        }]
                    });

                    return [polyline, decorator];
                },
                addLayers: (layers) => {
                    layers.forEach(layer => layer.addTo(map));
                },
                removeLayers: (layers) => {
                    layers.forEach(layer => map.removeLayer(layer));
                },
                clearAllLayers: () => {
                    Object.values(mapLayers).flat().forEach(layer => map.removeLayer(layer));
                    Object.values(pathLayers).flat().forEach(layer => map.removeLayer(layer));
                },
                fitBounds: (locations) => {
                    const group = new L.featureGroup(locations.map(loc => L.marker([loc.lat, loc.lng])));
                    map.fitBounds(group.getBounds().pad(0.1));
                }
            };

            const naverApi = {
                createMarker: (location, color, groupName) => {
                    const marker = new naver.maps.Marker({
                        position: new naver.maps.LatLng(location.lat, location.lng),
                        map: naverMap,
                        icon: {
                            content: `<div style="background-color:${color}; width:16px; height:16px; border-radius:50%; border: 2px solid white;"></div>`,
                            anchor: new naver.maps.Point(8, 8)
                        }
                    });

                    const detailsHtml = location.headers.map((header, idx) => 
                        (location.rawData[idx] && location.rawData[idx].toString().trim()) ? `<div class="detail-row"><span class="label">${header}:</span><span class="value">${location.rawData[idx]}</span></div>` : ''
                    ).join('');
                    const popupContent = `<div class="info-popup" style="padding:10px;"><h4>üìç ÏúÑÏπò Ï†ïÎ≥¥ (Row ${location.rowIndex})</h4>${detailsHtml}<div class="detail-row"><span class="label">Í∑∏Î£π:</span><span class="value">${groupName}</span></div></div>`;
                    
                    const infoWindow = new naver.maps.InfoWindow({
                        content: popupContent,
                        borderWidth: 0,
                        backgroundColor: 'transparent',
                        disableAnchor: true,
                        pixelOffset: new naver.maps.Point(0, -20)
                    });

                    naver.maps.Event.addListener(marker, 'mouseover', () => {
                        clearPopup();
                        infoWindow.open(naverMap, marker);
                        currentPopup = infoWindow;
                    });
                    naver.maps.Event.addListener(marker, 'mouseout', () => {
                        clearPopup();
                    });

                    return marker;
                },
                createPath: (locations, color) => {
                    const pathCoords = locations.map(loc => new naver.maps.LatLng(loc.lat, loc.lng));
                    const polyline = new naver.maps.Polyline({
                        map: naverMap,
                        path: pathCoords,
                        strokeColor: color,
                        strokeWeight: 4,
                        strokeOpacity: 0.8
                    });
                    return [polyline]; // Naver map doesn't have a simple decorator equivalent
                },
                addLayers: (layers) => {
                    layers.forEach(layer => layer.setMap(naverMap));
                },
                removeLayers: (layers) => {
                    layers.forEach(layer => layer.setMap(null));
                },
                clearAllLayers: () => {
                    Object.values(mapLayers).flat().forEach(layer => layer.setMap(null));
                    Object.values(pathLayers).flat().forEach(layer => layer.setMap(null));
                },
                fitBounds: (locations) => {
                    const bounds = new naver.maps.LatLngBounds(
                        new naver.maps.LatLng(locations[0].lat, locations[0].lng),
                        new naver.maps.LatLng(locations[0].lat, locations[0].lng)
                    );
                    locations.forEach(loc => bounds.extend(new naver.maps.LatLng(loc.lat, loc.lng)));
                    naverMap.fitBounds(bounds);
                }
            };

            return mapProvider === 'osm' ? leafletApi : naverApi;
        }

        // Í≤ΩÎ°ú ÌëúÏãú/Ïà®ÍπÄ
        function togglePaths() {
            showPaths = !showPaths;
            const pathToggle = document.getElementById('pathToggle');
            pathToggle.classList.toggle('active', showPaths);
            
            const mapApi = getMapApi();
            const allPathLayers = Object.values(pathLayers).flat();

            if (showPaths) {
                mapApi.addLayers(allPathLayers);
            } else {
                mapApi.removeLayers(allPathLayers);
            }
        }

        // ÏÉâÏÉÅ Ìï¥Ïãú Ìï®Ïàò
        function getColorForValue(value, index = 0) {
            if (!value) return colors[index % colors.length];
            
            let hash = 0;
            for (let i = 0; i < value.toString().length; i++) {
                hash = value.toString().charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Î∞è ÏßÄÎèÑÏóê ÌëúÏãú (ÏßÄÎèÑ ÎùºÏù¥Î∏åÎü¨Î¶¨ ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú)
        function processAndDisplayData(groupName, data, color, isSheetGroup = true) {
            if (!data || data.length === 0) return;

            const headers = data[0];
            const tsIndex = headers.findIndex(h => h && h.toString().toLowerCase().replace(/\s/g, '').includes('ts_local'));
            const latIndex = headers.findIndex(h => h && h.toString().toLowerCase().replace(/\s/g, '').includes('lat'));
            const lngIndex = headers.findIndex(h => h && h.toString().toLowerCase().replace(/\s/g, '').includes('lng'));

            if (tsIndex === -1 || latIndex === -1 || lngIndex === -1) {
                console.error(`ÌïÑÏöîÌïú Ïª¨Îüº(ts_local, lat, lng)ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${groupName}`);
                return;
            }

            const locations = data.slice(1)
                .map((row, index) => ({
                    timestamp: row[tsIndex],
                    lat: parseFloat(row[latIndex]),
                    lng: parseFloat(row[lngIndex]),
                    rawData: row,
                    headers: headers,
                    rowIndex: index + 2
                }))
                .filter(loc => !isNaN(loc.lat) && !isNaN(loc.lng) && loc.timestamp)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (locations.length === 0) return;

            const layerGroup = []; // ÎßàÏª§ Ï†ÄÏû•
            const pathLayerGroup = []; // Í≤ΩÎ°ú Ï†ÄÏû•
            mapLayers[groupName] = layerGroup;
            pathLayers[groupName] = pathLayerGroup;

            const mapApi = getMapApi();

            if (locations.length > 1) {
                const path = mapApi.createPath(locations, color);
                pathLayerGroup.push(...path);

                if (showPaths) {
                    mapApi.addLayers(path);
                }
            }

            locations.forEach((location, index) => {
                const marker = mapApi.createMarker(location, color, groupName);
                layerGroup.push(marker);
            });
            
            mapApi.addLayers(layerGroup);

            if (Object.keys(allData).filter(k => selectedSheets.has(k)).length === 1) {
                mapApi.fitBounds(locations);
            }
        }

        function updateColumnSelector() {
            const select = document.getElementById('groupColumn');
            select.innerHTML = '<option value="">ÏóÜÏùå</option>';
            allColumns.forEach(column => {
                const option = document.createElement('option');
                option.value = column;
                option.textContent = column;
                select.appendChild(option);
            });
        }

        function createGroupedData(columnName, sourceData) {
            const groupedData = {};
            Object.entries(sourceData).forEach(([sheetName, sheetData]) => {
                const headers = sheetData[0];
                const columnIndex = headers.findIndex(h => h && h.toString() === columnName);
                if (columnIndex === -1) return;
                const dataRows = sheetData.slice(1);
                dataRows.forEach(row => {
                    const groupValue = row[columnIndex] || 'Unknown';
                    if (!groupedData[groupValue]) {
                        groupedData[groupValue] = [headers];
                    }
                    groupedData[groupValue].push(row);
                });
            });
            return groupedData;
        }

        function createSheetControls() {
            const sheetControlsDiv = document.getElementById('sheetControls');
            sheetControlsDiv.innerHTML = '';
            
            Object.keys(allData).forEach((sheetName, index) => {
                const color = colors[index % colors.length];
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.className = 'checkbox-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `sheet_${sheetName.replace(/\s/g, '_')}`;
                checkbox.checked = selectedSheets.has(sheetName);

                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedSheets.add(sheetName);
                    } else {
                        selectedSheets.delete(sheetName);
                    }
                    onGroupColumnChange(); // Refresh map and groups
                    clearPopup();
                });
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = sheetName;
                label.style.color = color;
                label.style.fontWeight = '600';
                
                checkboxWrapper.append(checkbox, label);
                sheetControlsDiv.appendChild(checkboxWrapper);
            });
        }

        function createGroupControls(groupedData) {
            const groupControlsDiv = document.getElementById('groupControls');
            groupControlsDiv.innerHTML = '';
            const groupNames = Object.keys(groupedData);

            if (groupNames.length === 0) {
                groupControlsDiv.textContent = 'ÌëúÏãúÌï† Í∑∏Î£πÏù¥ ÏóÜÏäµÎãàÎã§. ÏãúÌä∏Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.';
                return;
            }

            groupNames.forEach((groupName, index) => {
                const color = getColorForValue(groupName, index);
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `group_${groupName.replace(/\s/g, '_')}`;
                checkbox.value = groupName;
                checkbox.checked = selectedGroups.has(groupName);

                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedGroups.add(groupName);
                    } else {
                        selectedGroups.delete(groupName);
                    }
                    onGroupColumnChange(); // Re-render with new selection
                });

                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = groupName;
                label.style.color = color;
                label.style.fontWeight = '600';

                const colorSwatch = document.createElement('span');
                colorSwatch.style.cssText = `width: 12px; height: 12px; background-color: ${color}; border-radius: 3px; display: inline-block;`;

                checkboxWrapper.append(checkbox, colorSwatch, label);
                groupControlsDiv.appendChild(checkboxWrapper);
            });
        }

        function processParsedData(results) {
            console.log('--- processParsedData ÏãúÏûë ---');
            
            if (results.errors.length > 0) {
                console.warn('CSV ÌååÏã± Ïò§Î•ò:', results.errors);
                document.getElementById('status').textContent = `ÌååÏã± Ïò§Î•ò: ${results.errors[0].message}`;
            }
            
            // Îç∞Ïù¥ÌÑ∞ Î∞è Î†àÏù¥Ïñ¥ Ï¥àÍ∏∞Ìôî
            getMapApi().clearAllLayers();
            allData = {}; mapLayers = {}; pathLayers = {}; allColumns = []; currentGroupColumn = ''; selectedSheets.clear();
            document.getElementById('groupColumn').value = '';
            
            const data = results.data;
            
            function isHeaderRow(row) {
                if (!row || row.length === 0) return false;
                const rowStr = row.map(cell => cell ? cell.toString().toLowerCase().replace(/\s/g, '') : '').join('');
                const hasRequiredCols = rowStr.includes('ts_local') && rowStr.includes('lat') && rowStr.includes('lng');
                return hasRequiredCols;
            }
            
            const headerIndices = data.map((row, i) => isHeaderRow(row) ? i : -1).filter(i => i !== -1);
            
            if (headerIndices.length === 0) {
                allData['Sheet1'] = data.filter(row => !isEmptyRow(row));
            } else {
                for (let i = 0; i < headerIndices.length; i++) {
                    const startIndex = headerIndices[i];
                    const endIndex = (i < headerIndices.length - 1) ? headerIndices[i + 1] : data.length;
                    let sheetData = data.slice(startIndex, endIndex).filter(row => !isEmptyRow(row));
                    if (sheetData.length > 1) {
                        const sheetName = `Sheet${i + 1}`;
                        allData[sheetName] = sheetData;
                    }
                }
            }

            if (Object.keys(allData).length === 0 && data.length > 0) {
                 allData['Sheet1'] = data.filter(row => !isEmptyRow(row));
            }

            Object.values(allData).forEach(sheetData => {
                if (sheetData.length > 0) {
                    sheetData[0].forEach(header => {
                        if (header && !allColumns.includes(header)) allColumns.push(header);
                    });
                }
            });

            updateColumnSelector();
            
            if (Object.keys(allData).length > 0) {
                selectedSheets.add(Object.keys(allData)[0]);
            }
            
            createSheetControls();
            onGroupColumnChange(); // Centralized UI refresh

            document.getElementById('status').textContent = `${Object.keys(allData).length}Í∞ú ÏãúÌä∏ Î°úÎìú ÏôÑÎ£å.`;
            console.log('--- processParsedData Ï¢ÖÎ£å ---');
        }

        function switchTab(tabId) {
            activeTab = tabId;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            const tabButton = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
            if (tabButton) tabButton.classList.add('active');

            const contentId = (tabId === 'sheets') ? 'sheetControls' : 'groupControls';
            const contentElement = document.getElementById(contentId);
            if (contentElement) contentElement.classList.add('active');
        }

        function displayDataAsGroups(groupColumn, sourceData) {
            const mapApi = getMapApi();
            mapApi.clearAllLayers();

            const allLocations = [];
            const groupValues = new Set();
            let tsIndex = -1, latIndex = -1, lngIndex = -1, groupIndex = -1;

            // 1. Consolidate all data points into a single list
            Object.values(sourceData).forEach(sheetData => {
                const headers = sheetData[0];
                if (tsIndex === -1) { // Find indices once
                    tsIndex = headers.findIndex(h => h && h.toString().toLowerCase().replace(/\s/g, '').includes('ts_local'));
                    latIndex = headers.findIndex(h => h && h.toString().toLowerCase().replace(/\s/g, '').includes('lat'));
                    lngIndex = headers.findIndex(h => h && h.toString().toLowerCase().replace(/\s/g, '').includes('lng'));
                    groupIndex = headers.findIndex(h => h && h.toString() === groupColumn);
                }

                if (tsIndex === -1 || latIndex === -1 || lngIndex === -1 || groupIndex === -1) return;

                sheetData.slice(1).forEach((row, index) => {
                    const groupValue = row[groupIndex] || 'Unknown';
                    groupValues.add(groupValue);
                    allLocations.push({
                        timestamp: row[tsIndex],
                        lat: parseFloat(row[latIndex]),
                        lng: parseFloat(row[lngIndex]),
                        group: groupValue,
                        rawData: row,
                        headers: headers,
                        rowIndex: index + 2
                    });
                });
            });

            // 2. Sort all points chronologically
            allLocations.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // If this is the first time grouping, select all groups by default
            if (selectedGroups.size === 0 && groupValues.size > 0) {
                groupValues.forEach(g => selectedGroups.add(g));
            }

            const visibleLocations = allLocations.filter(loc => selectedGroups.has(loc.group));
            
            const markerLayers = [];
            visibleLocations.forEach(loc => {
                if (isNaN(loc.lat) || isNaN(loc.lng)) return;
                const color = getColorForValue(loc.group);
                markerLayers.push(mapApi.createMarker(loc, color, loc.group));
            });
            mapApi.addLayers(markerLayers);
            mapLayers['groupedMarkers'] = markerLayers;

            // Path visibility logic
            const allGroupsSelected = selectedGroups.size === groupValues.size;
            const pathToggle = document.getElementById('pathToggle');
            
            if (showPaths && allGroupsSelected) {
                pathToggle.classList.add('active');
                const pathLayersArr = [];
                for (let i = 0; i < allLocations.length - 1; i++) {
                    const start = allLocations[i];
                    const end = allLocations[i+1];
                    if (isNaN(start.lat) || isNaN(start.lng) || isNaN(end.lat) || isNaN(end.lng)) continue;

                    const color = getColorForValue(start.group);
                    pathLayersArr.push(...mapApi.createPath([start, end], color));
                }
                mapApi.addLayers(pathLayersArr);
                pathLayers['groupedPaths'] = pathLayersArr;
            } else {
                pathToggle.classList.remove('active');
            }
            
            createGroupControls(Object.fromEntries(Array.from(groupValues).map(v => [v, []])));
            if (visibleLocations.length > 0) {
                mapApi.fitBounds(visibleLocations);
            }
        }

        function onGroupColumnChange() {
            const newGroupColumn = document.getElementById('groupColumn').value;
            
            // If group column changes, reset selected groups
            if (newGroupColumn !== currentGroupColumn) {
                selectedGroups.clear();
            }
            currentGroupColumn = newGroupColumn;
            
            const mapApi = getMapApi();
            mapApi.clearAllLayers();
            mapLayers = {}; pathLayers = {}; clearPopup();

            const visibleSheetData = {};
            selectedSheets.forEach(sheetName => {
                if (allData[sheetName]) visibleSheetData[sheetName] = allData[sheetName];
            });

            if (currentGroupColumn) {
                displayDataAsGroups(currentGroupColumn, visibleSheetData);
                switchTab('groups');
            } else {
                createGroupControls({});
                Object.entries(visibleSheetData).forEach(([sheetName, sheetData]) => {
                    const colorIndex = Object.keys(allData).indexOf(sheetName);
                    processAndDisplayData(sheetName, sheetData, colors[colorIndex % colors.length], true);
                });
                switchTab('sheets');
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('status').textContent = 'ÌååÏùº Ï≤òÎ¶¨ Ï§ë...';
            const reader = new FileReader();

            if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });

                        if (workbook.SheetNames.length === 0) {
                            document.getElementById('status').textContent = 'Ïò§Î•ò: XLSX ÌååÏùºÏóê ÏãúÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§.';
                            return;
                        }

                        // Îç∞Ïù¥ÌÑ∞ Î∞è Î†àÏù¥Ïñ¥ Ï¥àÍ∏∞Ìôî
                        getMapApi().clearAllLayers();
                        allData = {}; mapLayers = {}; pathLayers = {}; allColumns = []; currentGroupColumn = ''; selectedSheets.clear();
                        document.getElementById('groupColumn').value = '';
                        document.getElementById('sheetControls').innerHTML = '';
                        document.getElementById('groupControls').innerHTML = '';

                        workbook.SheetNames.forEach((sheetName) => {
                            const worksheet = workbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                            const sheetData = jsonData.filter(row => !isEmptyRow(row));
                            if (sheetData.length > 0) {
                                allData[sheetName] = sheetData;
                                sheetData[0].forEach(header => {
                                    if (header && !allColumns.includes(header)) allColumns.push(header);
                                });
                            }
                        });
                        
                        updateColumnSelector();
                        
                        if (Object.keys(allData).length > 0) {
                            selectedSheets.add(Object.keys(allData)[0]);
                        }
                        
                        createSheetControls();
                        onGroupColumnChange(); // Centralized UI refresh

                        document.getElementById('status').textContent = `${Object.keys(allData).length}Í∞ú ÏãúÌä∏ Î°úÎìú ÏôÑÎ£å.`;
                        
                    } catch (error) {
                        console.error('XLSX Ï≤òÎ¶¨ Ï§ë Ïã¨Í∞ÅÌïú Ïò§Î•ò Î∞úÏÉù:', error);
                        document.getElementById('status').textContent = `Ïò§Î•ò: XLSX ÌååÏùºÏùÑ Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§. (${error.message})`;
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                reader.onload = function(e) {
                    Papa.parse(e.target.result, {
                        header: false,
                        skipEmptyLines: true,
                        complete: processParsedData
                    });
                };
                reader.readAsText(file);
            }
        }

        function handleUrlLoad() {
            const url = document.getElementById('sheetUrl').value;
            if (!url) return alert('Íµ¨Í∏Ä Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ URLÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            
            const match = url.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            if (!match) return alert('Ïú†Ìö®Ìïú Íµ¨Í∏Ä Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ URLÏù¥ ÏïÑÎãôÎãàÎã§.');
            
            const sheetId = match[1];
            const gidMatch = url.match(/[#&]gid=([0-9]+)/);
            const gid = gidMatch ? gidMatch[1] : '0';
            
            const originalUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`;
            const csvUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(originalUrl)}`;
            
            document.getElementById('status').textContent = 'URLÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ï§ë...';
            Papa.parse(csvUrl, {
                download: true,
                header: false,
                skipEmptyLines: true,
                complete: processParsedData,
                error: (err) => {
                    document.getElementById('status').textContent = 'URL Î°úÎìú Ïò§Î•ò';
                    alert('Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§. URLÍ≥º ÏãúÌä∏ Í≥µÏú† ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
                }
            });
        }

        function toggleMapProvider() {
            const toggle = document.getElementById('mapProviderToggle');
            mapProvider = toggle.classList.contains('active') ? 'osm' : 'naver';
            toggle.classList.toggle('active');

            // ÎÑ§Ïù¥Î≤Ñ ÏßÄÎèÑÎ•º ÏÇ¨Ïö©ÌïòÎ†§Î©¥ Client IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.
            if (mapProvider === 'naver' && '[YOUR_CLIENT_ID_HERE]' === '[YOUR_CLIENT_ID_HERE]') {
                 alert('ÎÑ§Ïù¥Î≤Ñ ÏßÄÎèÑ APIÎ•º ÏÇ¨Ïö©ÌïòÎ†§Î©¥ index.html ÌååÏùºÏóêÏÑú [YOUR_CLIENT_ID_HERE]Î•º Ïã§Ï†ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ IDÎ°ú Î≥ÄÍ≤ΩÌï¥Ïïº Ìï©ÎãàÎã§.');
                 mapProvider = 'osm';
                 toggle.classList.remove('active');
                 return;
            }

            initMap();
            onGroupColumnChange(); // ÏßÄÎèÑ Î≥ÄÍ≤Ω ÌõÑ Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Í∑∏Î¶¨Í∏∞
        }

        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            document.getElementById('csvFile').addEventListener('change', handleFileSelect);
            document.getElementById('loadFromUrl').addEventListener('click', handleUrlLoad);
            document.getElementById('groupColumn').addEventListener('change', onGroupColumnChange);
            document.getElementById('pathToggle').addEventListener('click', togglePaths);
            document.getElementById('mapProviderToggle').addEventListener('click', toggleMapProvider);
            
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => switchTab(btn.dataset.tab));
            });
        });
    </script>
</body>
</html>
