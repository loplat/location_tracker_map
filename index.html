<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ„ì¹˜ ì¶”ì  ì§€ë„</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.1.0/leaflet.polylineDecorator.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ë„¤ì´ë²„ ì§€ë„ API (ì£¼ì˜: YOUR_CLIENT_IDë¥¼ ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ IDë¡œ ë³€ê²½í•´ì•¼ í•©ë‹ˆë‹¤) -->
    <script id="naverMapApi" type="text/javascript"
        src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=03aat0yes9"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .file-input-group,
        .url-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .file-input-group label,
        .url-input-group label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.9rem;
        }

        input[type="file"],
        input[type="url"] {
            padding: 12px;
            border: 2px solid #e0e6ed;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        input[type="file"]:focus,
        input[type="url"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .load-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .load-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }

        .map-container {
            flex: 1;
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .column-selector {
            margin-bottom: 15px;
        }

        .column-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            transition: border-color 0.3s ease;
        }

        .column-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .toggle-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        .tab-controls {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e6ed;
        }

        .tab-btn {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-weight: 600;
            color: #5f7d95;
            position: relative;
            transition: color 0.3s ease;
        }

        .tab-btn.active {
            color: #667eea;
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sheet-controls,
        .group-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }

        .checkbox-item:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
            transform: scale(1.1);
        }

        .checkbox-item label {
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
        }

        .status {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
            font-size: 13px;
            color: #6c757d;
            border: 1px solid #e9ecef;
        }

        .info-popup {
            font-family: inherit;
            max-width: 300px;
        }

        /* ê·¸ë£¹ íŠ¸ë¦¬ ìŠ¤íƒ€ì¼ */
        .group-tree details {
            margin: 5px 0;
            border-radius: 6px;
            transition: background 0.2s ease;
        }

        .group-tree details[style*="--force-collapse: none"] {
            display: none !important;
        }

        .group-tree details:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .group-tree summary {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .group-tree summary:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .group-tree summary::-webkit-details-marker {
            display: none;
        }

        .group-tree .group-arrow {
            transition: transform 0.2s ease;
            font-size: 12px;
            color: #666;
            margin-right: 8px;
        }

        .group-tree details[open] .group-arrow {
            transform: rotate(90deg);
        }

        .group-tree .group-label {
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .group-tree .group-label:hover {
            color: #667eea !important;
        }

        .info-popup h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 14px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .detail-row .label {
            font-weight: 600;
            color: #555;
            min-width: 80px;
        }

        .detail-row .value {
            color: #333;
            text-align: right;
            word-break: break-all;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .controls {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                flex-direction: row;
                overflow-x: auto;
            }

            .control-panel {
                min-width: 280px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ—ºï¸ ìœ„ì¹˜ ì¶”ì  ì§€ë„</h1>
            <div class="controls">
                <div class="file-input-group">
                    <label for="csvFile">ğŸ“ CSV/XLSX íŒŒì¼ ì—…ë¡œë“œ</label>
                    <input type="file" id="csvFile" accept=".csv,.xlsx,.xls">
                </div>
                <div class="url-input-group">
                    <label for="sheetUrl">ğŸ”— êµ¬ê¸€ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ URL</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="url" id="sheetUrl" placeholder="https://docs.google.com/spreadsheets/d/...">
                        <button class="load-btn" id="loadFromUrl">ë¡œë“œ</button>
                    </div>
                </div>
            </div>
            <div class="status" id="status">íŒŒì¼ì„ ì„ íƒí•˜ê±°ë‚˜ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”</div>
        </div>

        <div class="main-content">
            <div class="map-container">
                <div id="map"></div>
            </div>

            <div class="sidebar">
                <div class="control-panel">
                    <h3>âš™ï¸ í‘œì‹œ ì„¤ì •</h3>

                    <div class="toggle-section">
                        <span>ë„¤ì´ë²„ ì§€ë„ ì‚¬ìš©</span>
                        <div class="toggle-switch" id="mapProviderToggle"></div>
                    </div>

                    <div class="toggle-section">
                        <span>ê²½ë¡œ í‘œì‹œ</span>
                        <div class="toggle-switch active" id="pathToggle"></div>
                    </div>


                    <div id="groupingContainer">
                        <label for="group-selector-0">ğŸ·ï¸ ê·¸ë£¹ ê¸°ì¤€</label>
                        <div id="groupSelectors">
                            <!-- ë™ì  ê·¸ë£¹ ì„ íƒì ì¶”ê°€ë  ìœ„ì¹˜ -->
                        </div>
                        <button id="addGroupLevel"
                            style="width: 100%; padding: 8px; margin-top: 10px; border-radius: 6px; border: 1px solid #ccc; background: #f0f0f0; cursor: pointer;">+
                            ê·¸ë£¹ ë ˆë²¨ ì¶”ê°€</button>
                    </div>

                    <div class="tab-controls">
                        <button class="tab-btn active" data-tab="sheets">ğŸ“Š ì‹œíŠ¸</button>
                        <button class="tab-btn" data-tab="groups">ğŸ·ï¸ ê·¸ë£¹</button>
                    </div>

                    <div id="sheetControls" class="tab-content active"></div>
                    <div id="groupControls" class="tab-content"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let map;
        let naverMap;
        let mapProvider = 'osm'; // 'osm' or 'naver'
        let allData = {};
        let mapLayers = {};
        let pathLayers = {};
        let colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD', '#FF7675', '#74B9FF', '#A29BFE', '#6C5CE7', '#00B894', '#00CEC9', '#E84393', '#FD79A8'];
        let currentPopup = null;
        let showPaths = true;
        let currentGroupColumns = [];
        let allColumns = [];
        let activeTab = 'sheets';
        let selectedSheets = new Set();
        let selectedGroups = new Set();
        let allLocations = []; // ì „ì—­ ë³€ìˆ˜ë¡œ ì„ ì–¸
        let tsIndex = -1; // ì „ì—­ ë³€ìˆ˜ë¡œ ì„ ì–¸

        function excelSerialDateToJSDate(serial) {
            const utc_days = Math.floor(serial - 25569);
            const utc_value = utc_days * 86400;
            const date_info = new Date(utc_value * 1000);

            const fractional_day = serial - Math.floor(serial) + 0.0000001;

            let total_seconds = Math.floor(86400 * fractional_day);

            const seconds = total_seconds % 60;
            total_seconds -= seconds;

            const hours = Math.floor(total_seconds / (60 * 60));
            const minutes = Math.floor(total_seconds / 60) % 60;

            return new Date(date_info.getFullYear(), date_info.getMonth(), date_info.getDate(), hours, minutes, seconds);
        }

        function convertToKST(date) {
            const kstOffset = 9 * 60 * 60 * 1000;
            const kstDate = new Date(date.getTime() + kstOffset);
            return {
                date: kstDate.toISOString().slice(0, 10),
                time: kstDate.toISOString().slice(11, 19)
            };
        }

        function isEmptyRow(row) { return !row || row.every(cell => !cell || cell.toString().trim() === ''); }

        // ì§€ë„ ì´ˆê¸°í™”
        function initMap() {
            if (map) {
                map.remove();
                map = null;
            }
            if (naverMap) {
                naverMap.destroy();
                naverMap = null;
            }

            if (mapProvider === 'osm') {
                initLeafletMap();
            } else {
                initNaverMap();
            }
        }

        function initLeafletMap() {
            map = L.map('map').setView([37.5665, 126.9780], 11);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
            map.on('click', clearPopup);
        }

        function initNaverMap() {
            const mapOptions = {
                center: new naver.maps.LatLng(37.5665, 126.9780),
                tileTransition: false,
                zoom: 11,
                mapTypes: new naver.maps.MapTypeRegistry({
                    'normal': naver.maps.NaverStyleMapTypeOptions.getNormalMap(
                        {
                            overlayType: 'bg.ol.ts.lko'
                        }
                    )
                })
            };
            naverMap = new naver.maps.Map('map', mapOptions);
        }

        // ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜ (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // ì§€êµ¬ ë°˜ì§€ë¦„ (km)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // ì‹œê°„ ì°¨ì´ ê³„ì‚° í•¨ìˆ˜
        function calculateTimeDiff(time1, time2, returnMinutes = false) {
            const diff = Math.abs(new Date(time2) - new Date(time1)); // ms
            if (returnMinutes) return diff / (1000 * 60);

            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            return hours > 0 ? `${hours}ì‹œê°„ ${minutes}ë¶„` : `${minutes}ë¶„`;
        }

        // íŒì—… ì œê±° í•¨ìˆ˜
        function clearPopup() {
            if (currentPopup) {
                if (mapProvider === 'osm') {
                    map.closePopup(currentPopup);
                } else {
                    currentPopup.close();
                }
                currentPopup = null;
            }
        }

        // ì§€ë„ API ì–´ëŒ‘í„°
        function getMapApi() {
            const leafletApi = {
                createMarker: (location, color, groupName) => {
                    const marker = L.circleMarker([location.lat, location.lng], { radius: 8, fillColor: color, color: '#fff', weight: 2, opacity: 1, fillOpacity: 0.8 });
                    marker.on('mouseover', function (e) {
                        clearPopup();
                        const detailsHtml = location.headers.map((header, idx) =>
                            (location.rawData[idx] && location.rawData[idx].toString().trim()) ? `<div class="detail-row"><span class="label">${header}:</span><span class="value">${location.rawData[idx]}</span></div>` : ''
                        ).join('');
                        const popupContent = `<div class="info-popup"><h4>ğŸ“ ìœ„ì¹˜ ì •ë³´ (Row ${location.rowIndex})</h4>${detailsHtml}<div class="detail-row"><span class="label">ê·¸ë£¹:</span><span class="value">${groupName}</span></div></div>`;
                        currentPopup = L.popup({ closeButton: false, className: 'info-popup' }).setLatLng(e.latlng).setContent(popupContent).openOn(map);
                    });
                    marker.on('mouseout', clearPopup);
                    return marker;
                },
                createPath: (locations, color) => {
                    const pathCoords = locations.map(loc => [loc.lat, loc.lng]);
                    const polyline = L.polyline(pathCoords, { color: color, weight: 4, opacity: 0.8 });
                    const layers = [polyline];

                    for (let i = 0; i < locations.length - 1; i++) {
                        const start = locations[i];
                        const end = locations[i + 1];
                        const segmentCoords = [[start.lat, start.lng], [end.lat, end.lng]];
                        const segment = L.polyline(segmentCoords, { color: color, weight: 8, opacity: 0 }); // Thicker invisible line for easier hover

                        const distance = calculateDistance(start.lat, start.lng, end.lat, end.lng);
                        const timeDiffMinutes = calculateTimeDiff(start.timestamp, end.timestamp, true);
                        const timeDiffFormatted = calculateTimeDiff(start.timestamp, end.timestamp);
                        const speed = (timeDiffMinutes > 0) ? (distance / (timeDiffMinutes / 60)).toFixed(1) : 'N/A';

                        segment.on('mouseover', function (e) {
                            clearPopup();
                            const popupContent = `<div class="info-popup"><h4>ğŸ›£ï¸ ê²½ë¡œ ì •ë³´</h4>
                                <div class="detail-row"><span class="label">ê±°ë¦¬:</span><span class="value">${distance.toFixed(2)} km</span></div>
                                <div class="detail-row"><span class="label">ì‹œê°„:</span><span class="value">${timeDiffFormatted}</span></div>
                                <div class="detail-row"><span class="label">ì†ë„:</span><span class="value">${speed} km/h</span></div>
                            </div>`;
                            currentPopup = L.popup({ closeButton: false, className: 'info-popup' }).setLatLng(e.latlng).setContent(popupContent).openOn(map);
                        });
                        segment.on('mouseout', clearPopup);
                        layers.push(segment);
                    }

                    const decorator = L.polylineDecorator(polyline, {
                        patterns: [{
                            offset: 25,
                            repeat: 100,
                            symbol: L.Symbol.arrowHead({
                                pixelSize: 12,
                                polygon: false,
                                pathOptions: { stroke: true, weight: 2, color: color }
                            })
                        }]
                    });

                    layers.push(decorator);
                    return layers;
                },
                addLayers: (layers) => {
                    layers.forEach(layer => layer.addTo(map));
                },
                removeLayers: (layers) => {
                    layers.forEach(layer => map.removeLayer(layer));
                },
                clearAllLayers: () => {
                    Object.values(mapLayers).flat().forEach(layer => map.removeLayer(layer));
                    Object.values(pathLayers).flat().forEach(layer => map.removeLayer(layer));
                },
                fitBounds: (locations) => {
                    const group = new L.featureGroup(locations.map(loc => L.marker([loc.lat, loc.lng])));
                    map.fitBounds(group.getBounds().pad(0.1));
                },
                getBounds: (locations) => {
                    if (locations.length === 0) return null;
                    const group = new L.featureGroup(locations.map(loc => L.marker([loc.lat, loc.lng])));
                    return group.getBounds();
                }
            };

            const naverApi = {
                createMarker: (location, color, groupName) => {
                    const marker = new naver.maps.Marker({
                        position: new naver.maps.LatLng(location.lat, location.lng),
                        map: naverMap,
                        icon: {
                            content: `<div style="background-color:${color}; width:16px; height:16px; border-radius:50%; border: 2px solid white;"></div>`,
                            anchor: new naver.maps.Point(8, 8)
                        }
                    });

                    const detailsHtml = location.headers.map((header, idx) =>
                        (location.rawData[idx] && location.rawData[idx].toString().trim()) ? `<div class="detail-row"><span class="label">${header}:</span><span class="value">${location.rawData[idx]}</span></div>` : ''
                    ).join('');
                    const popupContent = `<div class="info-popup" style="padding:10px;"><h4>ğŸ“ ìœ„ì¹˜ ì •ë³´ (Row ${location.rowIndex})</h4>${detailsHtml}<div class="detail-row"><span class="label">ê·¸ë£¹:</span><span class="value">${groupName}</span></div></div>`;

                    const infoWindow = new naver.maps.InfoWindow({
                        content: popupContent,
                        borderWidth: 0,
                        backgroundColor: 'transparent',
                        disableAnchor: true,
                        pixelOffset: new naver.maps.Point(0, -20)
                    });

                    naver.maps.Event.addListener(marker, 'mouseover', () => {
                        clearPopup();
                        infoWindow.open(naverMap, marker);
                        currentPopup = infoWindow;
                    });
                    naver.maps.Event.addListener(marker, 'mouseout', () => {
                        clearPopup();
                    });

                    return marker;
                },
                createPath: (locations, color) => {
                    const pathCoords = locations.map(loc => new naver.maps.LatLng(loc.lat, loc.lng));
                    const polyline = new naver.maps.Polyline({
                        map: naverMap,
                        path: pathCoords,
                        strokeColor: color,
                        strokeWeight: 4,
                        strokeOpacity: 0.8
                    });

                    // Naver map doesn't support easy per-segment mouseover, so we'll attach a single event to the whole line
                    naver.maps.Event.addListener(polyline, 'mousemove', (e) => {
                        // This is a simplified approach. A proper implementation would involve finding the closest point on the polyline.
                        // For now, we just show a generic message. A more advanced implementation is out of scope.
                        clearPopup();
                        const popupContent = `<div class="info-popup" style="padding:10px;"><h4>ğŸ›£ï¸ ê²½ë¡œ ì •ë³´</h4><div>ê²½ë¡œ ìœ„ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë ¸ìŠµë‹ˆë‹¤.</div></div>`;
                        currentPopup = new naver.maps.InfoWindow({
                            content: popupContent,
                            position: e.coord,
                            borderWidth: 0,
                            backgroundColor: 'transparent',
                            disableAnchor: true,
                        });
                        currentPopup.open(naverMap);
                    });
                    naver.maps.Event.addListener(polyline, 'mouseout', () => {
                        clearPopup();
                    });

                    return [polyline];
                },
                addLayers: (layers) => {
                    layers.forEach(layer => layer.setMap(naverMap));
                },
                removeLayers: (layers) => {
                    layers.forEach(layer => layer.setMap(null));
                },
                clearAllLayers: () => {
                    Object.values(mapLayers).forEach(layerArray => layerArray.forEach(layer => layer.setMap(null)));
                    Object.values(pathLayers).forEach(layerArray => layerArray.forEach(layer => layer.setMap(null)));
                },
                fitBounds: (locations) => {
                    const bounds = new naver.maps.LatLngBounds(
                        new naver.maps.LatLng(locations[0].lat, locations[0].lng),
                        new naver.maps.LatLng(locations[0].lat, locations[0].lng)
                    );
                    locations.forEach(loc => bounds.extend(new naver.maps.LatLng(loc.lat, loc.lng)));
                    naverMap.fitBounds(bounds);
                },
                getBounds: (locations) => {
                    if (locations.length === 0) return null;
                    const bounds = new naver.maps.LatLngBounds(
                        new naver.maps.LatLng(locations[0].lat, locations[0].lng),
                        new naver.maps.LatLng(locations[0].lat, locations[0].lng)
                    );
                    locations.forEach(loc => bounds.extend(new naver.maps.LatLng(loc.lat, loc.lng)));
                    return bounds;
                }
            };
            return mapProvider === 'osm' ? leafletApi : naverApi;
        }

        // ê²½ë¡œ í‘œì‹œ/ìˆ¨ê¹€
        function togglePaths() {
            showPaths = !showPaths;
            const pathToggle = document.getElementById('pathToggle');
            pathToggle.classList.toggle('active', showPaths);

            const mapApi = getMapApi();
            const allPathLayers = Object.values(pathLayers).flat();

            if (showPaths) {
                // ê²½ë¡œë¥¼ ë‹¤ì‹œ ê·¸ë¦¬ê¸° ìœ„í•´ í˜„ì¬ ìƒíƒœë¡œ ë°ì´í„° ì¬ì²˜ë¦¬
                onGroupColumnChange();
            } else {
                mapApi.removeLayers(allPathLayers);
            }
        }

        // ìƒ‰ìƒ í•´ì‹œ í•¨ìˆ˜
        function getColorForValue(value, index = 0) {
            if (!value) return colors[index % colors.length];

            let hash = 0;
            for (let i = 0; i < value.toString().length; i++) {
                hash = value.toString().charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        function findColumnIndex(headers, keywords, exact = false) {
            for (const keyword of keywords) {
                const index = headers.findIndex(h => {
                    if (!h) return false;
                    const headerText = h.toString().toLowerCase().replace(/[\s_]/g, '');
                    return exact ? headerText === keyword : headerText.includes(keyword);
                });
                if (index !== -1) return index;
            }
            return -1;
        }

        // ë°ì´í„° ì²˜ë¦¬ ë° ì§€ë„ì— í‘œì‹œ (ì§€ë„ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë…ë¦½ì ìœ¼ë¡œ)
        function processAndDisplayData(groupName, data, color, isSheetGroup = true) {
            if (!data || data.length === 0) return;

            const headers = data[0];
            let tsIndex = findColumnIndex(headers, ['tslocal', 'timestamp', 'datetime']);
            const dateIndex = findColumnIndex(headers, ['date', 'day', 'ë‚ ì§œ']);
            const timeIndex = findColumnIndex(headers, ['time', 'ì‹œê°„']);
            const latIndex = findColumnIndex(headers, ['lat', 'latitude', 'ìœ„ë„']);
            const lngIndex = findColumnIndex(headers, ['lng', 'longitude', 'ê²½ë„']);

            const hasTimestamp = tsIndex !== -1 || (dateIndex !== -1 && timeIndex !== -1);

            if (!hasTimestamp || latIndex === -1 || lngIndex === -1) {
                alert(`í•„ìˆ˜ ì»¬ëŸ¼(ì‹œê°„, ìœ„ë„, ê²½ë„)ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. [ts_local/timestamp/datetime] ë˜ëŠ” [date/ë‚ ì§œ]ì™€ [time/ì‹œê°„] ì¡°í•©, ê·¸ë¦¬ê³  [lat/latitude/ìœ„ë„], [lng/longitude/ê²½ë„] ì¤‘ í•˜ë‚˜ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.`);
                console.error(`Could not find required columns in sheet: ${groupName}`);
                return;
            }

            const locations = data.slice(1)
                .map((row, index) => {
                    let date = row[dateIndex];
                    let time = row[timeIndex];

                    if (typeof date === 'number') {
                        const kst = convertToKST(excelSerialDateToJSDate(date));
                        date = kst.date;
                    }
                    if (typeof time === 'number') {
                        const kst = convertToKST(excelSerialDateToJSDate(time));
                        time = kst.time;
                    }

                    const timestamp = tsIndex !== -1 ? row[tsIndex] : `${date} ${time}`;

                    return {
                        timestamp: timestamp,
                        date: date,
                        time: time,
                        lat: parseFloat(row[latIndex]),
                        lng: parseFloat(row[lngIndex]),
                        rawData: row,
                        headers: headers,
                        rowIndex: index + 2
                    };
                })
                .filter(loc => !isNaN(loc.lat) && !isNaN(loc.lng) && loc.timestamp)
                .sort((a, b) => {
                    if (tsIndex !== -1) {
                        return new Date(a.timestamp) - new Date(b.timestamp);
                    }
                    // Custom sort for separate date and time columns
                    const dateA = new Date(a.date);
                    const dateB = new Date(b.date);
                    if (dateA > dateB) return 1;
                    if (dateA < dateB) return -1;
                    // If dates are the same, compare by time
                    return String(a.time).localeCompare(String(b.time));
                });

            if (locations.length === 0) return;

            console.log('locations:', locations.slice(0, 10));

            const layerGroup = [];
            const pathLayerGroup = [];
            mapLayers[groupName] = layerGroup;
            pathLayers[groupName] = pathLayerGroup;

            const mapApi = getMapApi();

            // 1. Draw markers first
            locations.forEach((location) => {
                const marker = mapApi.createMarker(location, color, groupName);
                layerGroup.push(marker);
            });
            mapApi.addLayers(layerGroup);

            // 2. Draw paths (especially for Naver map, this can be deferred)
            const drawPaths = () => {
                if (locations.length > 1 && showPaths) {
                    const path = mapApi.createPath(locations, color);
                    pathLayerGroup.push(...path);
                    mapApi.addLayers(path);
                }
            };

            if (mapProvider === 'naver') {
                setTimeout(drawPaths, 100); // Defer path drawing slightly
            } else {
                drawPaths();
            }

            if (Object.keys(allData).filter(k => selectedSheets.has(k)).length === 1) {
                mapApi.fitBounds(locations);
            }
        }

        function updateColumnSelector(selectElement) {
            const existingValue = selectElement.value;
            selectElement.innerHTML = '<option value="">ì—†ìŒ</option>';
            allColumns.forEach(column => {
                const option = document.createElement('option');
                option.value = column;
                option.textContent = column;
                selectElement.appendChild(option);
            });
            selectElement.value = existingValue;
        }

        function addGroupSelector(selectedColumn = '') {
            const container = document.getElementById('groupSelectors');
            const selectorId = `group-selector-${container.children.length}`;

            const wrapper = document.createElement('div');
            wrapper.className = 'group-selector-wrapper';
            wrapper.style.display = 'flex';
            wrapper.style.gap = '5px';
            wrapper.style.marginBottom = '5px';

            const select = document.createElement('select');
            select.id = selectorId;
            select.className = 'group-column-selector';
            select.style.flex = '1';
            select.style.padding = '8px';
            select.style.borderRadius = '6px';
            select.style.border = '1px solid #ccc';

            updateColumnSelector(select);
            select.value = selectedColumn;
            select.addEventListener('change', onGroupColumnChange);

            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'X';
            removeBtn.style.padding = '0 10px';
            removeBtn.style.border = '1px solid #ccc';
            removeBtn.style.background = '#f0f0f0';
            removeBtn.style.borderRadius = '6px';
            removeBtn.style.cursor = 'pointer';
            removeBtn.addEventListener('click', () => {
                wrapper.remove();
                onGroupColumnChange();
            });

            wrapper.appendChild(select);
            wrapper.appendChild(removeBtn);
            container.appendChild(wrapper);
        }

        function createGroupedData(columnName, sourceData) {
            const groupedData = {};
            Object.entries(sourceData).forEach(([sheetName, sheetData]) => {
                const headers = sheetData[0];
                const columnIndex = headers.findIndex(h => h && h.toString() === columnName);
                if (columnIndex === -1) return;
                const dataRows = sheetData.slice(1);
                dataRows.forEach(row => {
                    const groupValue = row[columnIndex] || 'Unknown';
                    if (!groupedData[groupValue]) {
                        groupedData[groupValue] = [headers];
                    }
                    groupedData[groupValue].push(row);
                });
            });
            return groupedData;
        }

        function createSheetControls() {
            const sheetControlsDiv = document.getElementById('sheetControls');
            sheetControlsDiv.innerHTML = '';

            Object.entries(allData).forEach(([sheetName, sheetData], index) => {
                const color = colors[index % colors.length];
                const rowCount = sheetData.length > 0 ? sheetData.length - 1 : 0; // Subtract header row

                let totalDistance = 0;
                if (rowCount > 1) {
                    const headers = sheetData[0];
                    const latIndex = findColumnIndex(headers, ['lat', 'latitude', 'ìœ„ë„']);
                    const lngIndex = findColumnIndex(headers, ['lng', 'longitude', 'ê²½ë„']);
                    if (latIndex !== -1 && lngIndex !== -1) {
                        for (let i = 1; i < sheetData.length - 1; i++) {
                            const lat1 = parseFloat(sheetData[i][latIndex]);
                            const lon1 = parseFloat(sheetData[i][lngIndex]);
                            const lat2 = parseFloat(sheetData[i + 1][latIndex]);
                            const lon2 = parseFloat(sheetData[i + 1][lngIndex]);
                            if (!isNaN(lat1) && !isNaN(lon1) && !isNaN(lat2) && !isNaN(lon2)) {
                                totalDistance += calculateDistance(lat1, lon1, lat2, lon2);
                            }
                        }
                    }
                }

                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.className = 'checkbox-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `sheet_${sheetName.replace(/\s/g, '_')}`;
                checkbox.checked = selectedSheets.has(sheetName);

                checkbox.addEventListener('change', function () {
                    if (this.checked) {
                        selectedSheets.add(sheetName);
                    } else {
                        selectedSheets.delete(sheetName);
                    }

                    // ì‹œíŠ¸ ë³€ê²½ ì‹œ í•´ë‹¹ ì‹œíŠ¸ì˜ ë ˆì´ì–´ë§Œ ì œê±°í•˜ê³  ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                    const mapApi = getMapApi();

                    // í˜„ì¬ ì‹œíŠ¸ì˜ ë§ˆì»¤ì™€ ê²½ë¡œ ì œê±°
                    if (mapLayers[sheetName]) {
                        mapApi.removeLayers(mapLayers[sheetName]);
                        delete mapLayers[sheetName];
                    }
                    if (pathLayers[sheetName]) {
                        mapApi.removeLayers(pathLayers[sheetName]);
                        delete pathLayers[sheetName];
                    }

                    // ê·¸ë£¹ ëª¨ë“œì¸ ê²½ìš° ê·¸ë£¹ ë ˆì´ì–´ë„ ì œê±°
                    if (mapLayers['groupedMarkers']) {
                        mapApi.removeLayers(mapLayers['groupedMarkers']);
                        delete mapLayers['groupedMarkers'];
                    }
                    if (pathLayers['groupedPaths']) {
                        mapApi.removeLayers(pathLayers['groupedPaths']);
                        delete pathLayers['groupedPaths'];
                    }

                    onGroupColumnChange(); // Refresh map and groups
                    clearPopup();
                });

                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = `${sheetName} (${rowCount}ê±´, ${totalDistance.toFixed(2)}km)`;
                label.style.color = color;
                label.style.fontWeight = '600';

                checkboxWrapper.append(checkbox, label);
                sheetControlsDiv.appendChild(checkboxWrapper);
            });
        }

        function updateMapDisplay() {
            if (currentGroupColumns.length === 0) return;

            const mapApi = getMapApi();

            // ê¸°ì¡´ ê·¸ë£¹ ë ˆì´ì–´ë“¤ ì œê±°
            if (mapLayers['groupedMarkers']) {
                mapApi.removeLayers(mapLayers['groupedMarkers']);
                delete mapLayers['groupedMarkers'];
            }
            if (pathLayers['groupedPaths']) {
                mapApi.removeLayers(pathLayers['groupedPaths']);
                delete pathLayers['groupedPaths'];
            }

            const visibleSheetData = {};
            selectedSheets.forEach(sheetName => {
                if (allData[sheetName]) visibleSheetData[sheetName] = allData[sheetName];
            });

            // ë¹ ë¥¸ ì§€ë„ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ê¸°ì¡´ ë¡œì§ ì¬ì‚¬ìš© (ê·¸ë£¹ ì»¨íŠ¸ë¡¤ì€ ìƒì„±í•˜ì§€ ì•ŠìŒ)
            displayDataAsGroups(currentGroupColumns, visibleSheetData, false);
        }

        function createGroupControls(hierarchicalData) {
            const groupControlsDiv = document.getElementById('groupControls');

            // ê¸°ì¡´ details ìš”ì†Œë“¤ì˜ ì—´ë¦¼/ë‹«í˜ ìƒíƒœë¥¼ ì €ì¥
            const existingStates = {};
            if (groupControlsDiv.children.length > 0) {
                const existingDetails = groupControlsDiv.querySelectorAll('details');
                existingDetails.forEach(details => {
                    const summary = details.querySelector('summary');
                    if (summary) {
                        const label = summary.querySelector('.group-label');
                        if (label) {
                            const key = label.textContent.split(' (')[0]; // ê·¸ë£¹ëª…ë§Œ ì¶”ì¶œ
                            existingStates[key] = details.open;
                        }
                    }
                });
            }

            groupControlsDiv.innerHTML = '';
            groupControlsDiv.className = 'group-controls group-tree';

            if (Object.keys(hierarchicalData).length === 0) {
                groupControlsDiv.textContent = 'í‘œì‹œí•  ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤. ì‹œíŠ¸ë¥¼ ì„ íƒí•˜ê±°ë‚˜ ê·¸ë£¹ ê¸°ì¤€ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.';
                return;
            }

            // ì¬ê·€ì ìœ¼ë¡œ ê±´ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
            function calculateCount(data) {
                console.log('=== calculateCount í˜¸ì¶œ ===');
                console.log('data:', data);
                console.log('Array.isArray(data):', Array.isArray(data));

                if (Array.isArray(data)) {
                    const result = data.length;
                    console.log('ë°°ì—´ì´ë¯€ë¡œ ê²°ê³¼:', result);
                    return result;
                } else {
                    let total = 0;
                    Object.values(data).forEach(value => {
                        total += calculateCount(value);
                    });
                    console.log('ê°ì²´ì´ë¯€ë¡œ ê²°ê³¼:', total);
                    return total;
                }
            }

            // ìì‹ì´ ì„ íƒë˜ì§€ ì•Šì€ ë¶€ëª¨ë¥¼ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
            function hasSelectedChildren(data, level = 0) {
                console.log('=== hasSelectedChildren í˜¸ì¶œ ===');
                console.log('data:', data);
                console.log('level:', level);
                console.log('Array.isArray(data):', Array.isArray(data));

                if (Array.isArray(data)) {
                    const result = data.length > 0;
                    console.log('ë°°ì—´ì´ë¯€ë¡œ ê²°ê³¼:', result);
                    return result;
                } else {
                    const result = Object.values(data).some(value => hasSelectedChildren(value, level + 1));
                    console.log('ê°ì²´ì´ë¯€ë¡œ ê²°ê³¼:', result);
                    return result;
                }
            }

            // ë¶€ëª¨ ê·¸ë£¹ ìë™ ì ‘ê¸°/ì²´í¬ í•¨ìˆ˜ (íŠ¹ì • ë¶€ëª¨ ê·¸ë£¹ë§Œ ì²˜ë¦¬)
            function updateParentGroupState(parentDetails) {
                console.log('=== updateParentGroupState ì‹œì‘ ===');
                console.log('parentDetails:', parentDetails);

                if (!parentDetails) {
                    console.log('parentDetailsê°€ nullì´ë¯€ë¡œ ì¢…ë£Œ');
                    return;
                }

                // ë¶€ëª¨ ì²´í¬ë°•ìŠ¤ëŠ” ì œì™¸í•˜ê³  ì§ì ‘ì ì¸ ìì‹ ì²´í¬ë°•ìŠ¤ë§Œ ì„ íƒ
                const parentCheckbox = parentDetails.querySelector('summary input[type="checkbox"]');
                const allChildCheckboxes = parentDetails.querySelectorAll('details > summary input[type="checkbox"]');
                // ë¶€ëª¨ ì²´í¬ë°•ìŠ¤ë¥¼ ì œì™¸í•œ ì§ì ‘ì ì¸ ìì‹ ì²´í¬ë°•ìŠ¤ë§Œ í•„í„°ë§
                const childCheckboxes = Array.from(allChildCheckboxes).filter(checkbox =>
                    checkbox !== parentCheckbox &&
                    checkbox.closest('details').parentElement === parentDetails
                );

                console.log('childCheckboxes ê°œìˆ˜:', childCheckboxes.length);
                console.log('parentCheckbox:', parentCheckbox);

                if (!parentCheckbox || childCheckboxes.length === 0) {
                    console.log('parentCheckboxê°€ ì—†ê±°ë‚˜ childCheckboxesê°€ ì—†ìœ¼ë¯€ë¡œ ì¢…ë£Œ');
                    return;
                }

                const checkedChildren = Array.from(childCheckboxes).filter(checkbox => checkbox.checked);
                const totalChildren = childCheckboxes.length;

                console.log('checkedChildren ê°œìˆ˜:', checkedChildren.length);
                console.log('totalChildren:', totalChildren);
                console.log('parentCheckbox í˜„ì¬ ìƒíƒœ:', parentCheckbox.checked);
                console.log('parentCheckbox dataset.key:', parentCheckbox.dataset.key);

                // ëª¨ë“  ìì‹ì´ ì„ íƒë˜ì—ˆëŠ”ì§€ í™•ì¸
                const allChildrenSelected = checkedChildren.length === totalChildren;
                // ì„ íƒëœ ìì‹ì´ ìˆëŠ”ì§€ í™•ì¸
                const hasSelectedChildren = checkedChildren.length > 0;

                console.log('allChildrenSelected:', allChildrenSelected);
                console.log('hasSelectedChildren:', hasSelectedChildren);

                if (allChildrenSelected) {
                    console.log('ëª¨ë“  ìì‹ì´ ì„ íƒë¨ - ë¶€ëª¨ë„ ì„ íƒ');
                    // ëª¨ë“  ìì‹ì´ ì„ íƒë˜ë©´ ë¶€ëª¨ë„ ì„ íƒ
                    if (!parentCheckbox.checked) {
                        console.log('ë¶€ëª¨ ì²´í¬ë°•ìŠ¤ë¥¼ ì²´í¬ë¡œ ë³€ê²½');
                        parentCheckbox.checked = true;
                        selectedGroups.add(parentCheckbox.dataset.key);
                        console.log('selectedGroupsì— ì¶”ê°€ë¨:', parentCheckbox.dataset.key);
                    } else {
                        console.log('ë¶€ëª¨ê°€ ì´ë¯¸ ì²´í¬ë˜ì–´ ìˆìŒ');
                    }
                } else if (!hasSelectedChildren) {
                    console.log('ì„ íƒëœ ìì‹ì´ ì—†ìŒ - ë¶€ëª¨ ì²´í¬ í•´ì œ ë° ì ‘ê¸°');
                    // ì„ íƒëœ ìì‹ì´ ì—†ìœ¼ë©´ ë¶€ëª¨ ì²´í¬ í•´ì œ ë° ì ‘ê¸°
                    if (parentCheckbox.checked) {
                        console.log('ë¶€ëª¨ ì²´í¬ë°•ìŠ¤ë¥¼ ì²´í¬ í•´ì œë¡œ ë³€ê²½');
                        parentCheckbox.checked = false;
                        selectedGroups.delete(parentCheckbox.dataset.key);
                        console.log('selectedGroupsì—ì„œ ì œê±°ë¨:', parentCheckbox.dataset.key);
                    } else {
                        console.log('ë¶€ëª¨ê°€ ì´ë¯¸ ì²´í¬ í•´ì œë˜ì–´ ìˆìŒ');
                    }
                    console.log('ë¶€ëª¨ ê·¸ë£¹ì„ ì ‘ìŒ (open = false)');
                    forceCollapseDetails(parentDetails);
                } else {
                    console.log('ì¼ë¶€ ìì‹ë§Œ ì„ íƒë¨ - ìƒíƒœ ë³€ê²½ ì—†ìŒ');
                }

                console.log('=== updateParentGroupState ì¢…ë£Œ ===');
            }

            // ê°•ì œë¡œ details ìš”ì†Œë¥¼ ì ‘ëŠ” í•¨ìˆ˜
            function forceCollapseDetails(detailsElement) {
                if (!detailsElement) return;

                console.log('forceCollapseDetails í˜¸ì¶œë¨, í˜„ì¬ details.open:', detailsElement.open);

                // ì¦‰ì‹œ ì ‘ê¸° ì‹œë„
                detailsElement.open = false;
                console.log('ì¦‰ì‹œ ì ‘ê¸° í›„ details.open:', detailsElement.open);

                // CSSë¥¼ í†µí•œ ê°•ì œ ì ‘ê¸°
                detailsElement.style.setProperty('--force-collapse', 'none');
                detailsElement.style.setProperty('display', 'block');

                // ì§€ì—°ì„ ë‘ì–´ ë‹¤ë¥¸ ì‘ì—…ì´ ì™„ë£Œëœ í›„ ë‹¤ì‹œ ì ‘ê¸° ì‹œë„
                setTimeout(() => {
                    detailsElement.open = false;
                    console.log('ì§€ì—° ì ‘ê¸° í›„ details.open:', detailsElement.open);
                }, 50);

                // ì¶”ê°€ ì§€ì—°ìœ¼ë¡œ í•œ ë²ˆ ë” ì‹œë„
                setTimeout(() => {
                    detailsElement.open = false;
                    console.log('ìµœì¢… ì ‘ê¸° í›„ details.open:', detailsElement.open);
                }, 150);

                // ë” ê¸´ ì§€ì—°ìœ¼ë¡œ í•œ ë²ˆ ë” ì‹œë„
                setTimeout(() => {
                    detailsElement.open = false;
                    console.log('ìµœì¢… ìµœì¢… ì ‘ê¸° í›„ details.open:', detailsElement.open);
                }, 500);
            }

            // ì „ì²´ ë¶€ëª¨ ê·¸ë£¹ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            function updateAllParentGroups() {
                const allDetails = groupControlsDiv.querySelectorAll('details');
                allDetails.forEach(details => {
                    updateParentGroupState(details);
                });
            }

            // ê·¸ë£¹ ê¹œë¹¡ì´ê¸° í•¨ìˆ˜
            function blinkGroup(groupKey) {
                const mapApi = getMapApi();

                // í˜„ì¬ í‘œì‹œëœ ë§ˆì»¤ë“¤ì—ì„œ í•´ë‹¹ ê·¸ë£¹ì˜ ìœ„ì¹˜ ì°¾ê¸°
                const groupLocations = [];

                // mapLayers['groupedMarkers']ì—ì„œ í•´ë‹¹ ê·¸ë£¹ì˜ ë§ˆì»¤ë“¤ ì°¾ê¸°
                if (mapLayers['groupedMarkers']) {
                    mapLayers['groupedMarkers'].forEach((marker) => {
                        // ë§ˆì»¤ì— ì €ì¥ëœ ìœ„ì¹˜ ë°ì´í„° ì‚¬ìš©
                        if (marker.locationData && marker.locationData.group === groupKey) {
                            groupLocations.push(marker.locationData);
                        }
                    });
                }

                if (groupLocations.length === 0) return;

                // ê¹œë¹¡ì´ê¸° íš¨ê³¼ë¥¼ ìœ„í•œ ì„ì‹œ ìŠ¤íƒ€ì¼
                const blinkStyle = {
                    opacity: 0.3,
                    weight: 5,
                    color: '#ff0000'
                };

                // ë§ˆì»¤ì™€ ê²½ë¡œì— ê¹œë¹¡ì´ê¸° íš¨ê³¼ ì ìš©
                const blinkElements = [];

                // ë§ˆì»¤ ê¹œë¹¡ì´ê¸°
                groupLocations.forEach(loc => {
                    if (!isNaN(loc.lat) && !isNaN(loc.lng)) {
                        const marker = mapApi.createMarker(loc, '#ff0000', groupKey);
                        // Leafletì˜ ê²½ìš° setStyle ë©”ì„œë“œ ì‚¬ìš©
                        if (mapProvider === 'osm' && marker.setStyle) {
                            marker.setStyle(blinkStyle);
                        }
                        blinkElements.push(marker);
                    }
                });

                // ê²½ë¡œ ê¹œë¹¡ì´ê¸°
                if (groupLocations.length > 1) {
                    // ì‹œê°„ìˆœìœ¼ë¡œ ì •ë ¬
                    const sortedLocs = [...groupLocations].sort((a, b) => {
                        if (a.timestamp && b.timestamp) {
                            return new Date(a.timestamp) - new Date(b.timestamp);
                        }
                        const dateA = new Date(a.date);
                        const dateB = new Date(b.date);
                        if (dateA > dateB) return 1;
                        if (dateA < dateB) return -1;
                        return String(a.time).localeCompare(String(b.time));
                    });

                    for (let i = 0; i < sortedLocs.length - 1; i++) {
                        const start = sortedLocs[i];
                        const end = sortedLocs[i + 1];
                        if (!isNaN(start.lat) && !isNaN(start.lng) && !isNaN(end.lat) && !isNaN(end.lng)) {
                            const path = mapApi.createPath([start, end], '#ff0000');
                            // Leafletì˜ ê²½ìš° setStyle ë©”ì„œë“œ ì‚¬ìš©
                            if (mapProvider === 'osm') {
                                path.forEach(p => {
                                    if (p.setStyle) p.setStyle(blinkStyle);
                                });
                            }
                            blinkElements.push(...path);
                        }
                    }
                }

                // ê¹œë¹¡ì´ê¸° ìš”ì†Œë“¤ì„ ì§€ë„ì— ì¶”ê°€
                mapApi.addLayers(blinkElements);

                // 1ì´ˆ í›„ ê¹œë¹¡ì´ê¸° íš¨ê³¼ ì œê±°
                setTimeout(() => {
                    mapApi.removeLayers(blinkElements);
                }, 1000);

                // ê·¸ë£¹ì´ í™”ë©´ ë°–ì— ìˆìœ¼ë©´ í¬ì»¤ìŠ¤ ì´ë™
                if (groupLocations.length > 0) {
                    mapApi.fitBounds(groupLocations);
                }
            }

            const buildGroupTree = (data, parentElement, level = 0, parentKey = '') => {
                console.log('=== buildGroupTree í˜¸ì¶œ ===');
                console.log('data:', data);
                console.log('parentElement:', parentElement);
                console.log('level:', level);
                console.log('parentKey:', parentKey);

                Object.entries(data).forEach(([key, value]) => {
                    const currentFullKey = parentKey ? `${parentKey}|${key}` : key;
                    const count = calculateCount(value);
                    const hasChildren = !Array.isArray(value);
                    const shouldCollapse = hasChildren && !hasSelectedChildren(value);

                    console.log('key:', key);
                    console.log('currentFullKey:', currentFullKey);
                    console.log('count:', count);
                    console.log('hasChildren:', hasChildren);
                    console.log('shouldCollapse:', shouldCollapse);

                    const details = document.createElement('details');
                    details.className = 'group-tree';

                    // ê¸°ì¡´ ìƒíƒœê°€ ìˆìœ¼ë©´ ì ìš©, ì—†ìœ¼ë©´ ìë™ ì ‘ê¸° ë¡œì§ ì‚¬ìš©
                    if (existingStates.hasOwnProperty(key)) {
                        details.open = existingStates[key];
                        console.log(`ê¸°ì¡´ ìƒíƒœ ì ìš©: ${key} = ${existingStates[key]}`);
                    } else {
                        details.open = !shouldCollapse; // ìì‹ì´ ì„ íƒë˜ì§€ ì•Šì€ ë¶€ëª¨ëŠ” ì ‘ê¸°
                        console.log(`ìë™ ì ‘ê¸° ë¡œì§ ì ìš©: ${key} = ${!shouldCollapse}`);
                    }

                    details.style.marginLeft = `${level * 15}px`;

                    const summary = document.createElement('summary');
                    summary.style.display = 'flex';
                    summary.style.alignItems = 'center';
                    summary.style.gap = '8px';
                    summary.style.cursor = 'pointer';

                    // í™”ì‚´í‘œ ì•„ì´ì½˜ ì¶”ê°€
                    const arrow = document.createElement('span');
                    arrow.className = 'group-arrow';
                    arrow.innerHTML = 'â–¶';

                    // details ìƒíƒœì— ë”°ë¼ í™”ì‚´í‘œ íšŒì „
                    details.addEventListener('toggle', () => {
                        arrow.style.transform = details.open ? 'rotate(90deg)' : 'rotate(0deg)';
                    });

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `group-checkbox-${currentFullKey.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    checkbox.checked = selectedGroups.has(currentFullKey);
                    checkbox.dataset.key = currentFullKey;

                    checkbox.addEventListener('change', (e) => {
                        e.stopPropagation();
                        const isChecked = e.target.checked;
                        const key = e.target.dataset.key;

                        // í˜„ì¬ ì²´í¬ë°•ìŠ¤ ìƒíƒœ ë³€ê²½
                        if (isChecked) {
                            selectedGroups.add(key);
                        } else {
                            selectedGroups.delete(key);
                        }

                        // í•˜ìœ„ ì²´í¬ë°•ìŠ¤ë“¤ë„ ë™ì¼í•˜ê²Œ ì„¤ì • (ì§ì ‘ì ì¸ ìì‹ë§Œ)
                        const allChildCheckboxes = details.querySelectorAll('details > summary input[type="checkbox"]');
                        // í˜„ì¬ ì²´í¬ë°•ìŠ¤ë¥¼ ì œì™¸í•œ ì§ì ‘ì ì¸ ìì‹ ì²´í¬ë°•ìŠ¤ë§Œ í•„í„°ë§
                        const childCheckboxes = Array.from(allChildCheckboxes).filter(checkbox =>
                            checkbox !== e.target &&
                            checkbox.closest('details').parentElement === details
                        );
                        childCheckboxes.forEach(child => {
                            child.checked = isChecked;
                            if (isChecked) {
                                selectedGroups.add(child.dataset.key);
                            } else {
                                selectedGroups.delete(child.dataset.key);
                            }
                        });

                        // ë¶€ëª¨ ê·¸ë£¹ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì§ì ‘ ë¶€ëª¨ë§Œ)
                        console.log('=== ì²´í¬ë°•ìŠ¤ ë³€ê²½ ì´ë²¤íŠ¸ ===');
                        console.log('ë³€ê²½ëœ ì²´í¬ë°•ìŠ¤:', checkbox);
                        console.log('ì²´í¬ë°•ìŠ¤ ìƒíƒœ:', checkbox.checked);
                        console.log('ì²´í¬ë°•ìŠ¤ dataset.key:', checkbox.dataset.key);

                        const parentDetails = details.parentElement.closest('details');
                        console.log('ì°¾ì€ ë¶€ëª¨ details:', parentDetails);

                        if (parentDetails) {
                            console.log('ë¶€ëª¨ detailsê°€ ì¡´ì¬í•˜ë¯€ë¡œ updateParentGroupState í˜¸ì¶œ');
                            updateParentGroupState(parentDetails);
                        } else {
                            console.log('ë¶€ëª¨ detailsê°€ ì—†ìŒ');
                        }

                        // ì§€ë„ ì—…ë°ì´íŠ¸ - ì „ì²´ë¥¼ ë‹¤ì‹œ ê·¸ë¦¬ì§€ ì•Šê³  ì„ íƒëœ ê·¸ë£¹ë§Œ ì²˜ë¦¬
                        console.log('í˜„ì¬ selectedGroups ìƒíƒœ:', Array.from(selectedGroups));
                        console.log('ì²´í¬ë°•ìŠ¤ ë³€ê²½ í›„ details.open ìƒíƒœ:', details.open);
                        if (currentGroupColumns.length > 0) {
                            // ì§€ì—°ì„ ë‘ì–´ collapse ì‘ì—…ì´ ì™„ë£Œëœ í›„ ì§€ë„ ì—…ë°ì´íŠ¸
                            setTimeout(() => {
                                console.log('updateMapDisplay í˜¸ì¶œ ì „ details.open ìƒíƒœ:', details.open);
                                updateMapDisplay();
                                console.log('updateMapDisplay í˜¸ì¶œ í›„ details.open ìƒíƒœ:', details.open);
                            }, 300); // ë” ê¸´ ì§€ì—° ì‹œê°„
                        }
                    });

                    const label = document.createElement('span');
                    label.className = 'group-label';
                    label.textContent = `${key} (${count}ê±´)`;
                    label.style.fontWeight = '600';
                    label.style.color = getColorForValue(key);

                    // ê·¸ë£¹ëª… í´ë¦­ ì´ë²¤íŠ¸
                    label.addEventListener('click', (e) => {
                        e.stopPropagation();
                        blinkGroup(currentFullKey);
                    });

                    summary.append(arrow, checkbox, label);
                    details.appendChild(summary);

                    if (Array.isArray(value)) { // Leaf node
                        // No further nesting
                    } else { // Branch node
                        buildGroupTree(value, details, level + 1, currentFullKey);
                    }
                    parentElement.appendChild(details);
                });
            };

            buildGroupTree(hierarchicalData, groupControlsDiv);
        }

        function processLoadedData(parsedData) {
            console.log('--- processLoadedData ì‹œì‘ ---');

            // ë°ì´í„° ë° ë ˆì´ì–´ ì´ˆê¸°í™”
            getMapApi().clearAllLayers();
            allData = {}; mapLayers = {}; pathLayers = {}; allColumns = []; currentGroupColumns = []; selectedSheets.clear();
            document.getElementById('groupSelectors').innerHTML = '';

            function isHeaderRow(row) {
                if (!row || row.length === 0) return false;
                const lowerRow = row.map(cell => cell ? cell.toString().toLowerCase().replace(/[\s_]/g, '') : '');
                const hasCombinedTimestamp = lowerRow.some(cell => ['tslocal', 'timestamp', 'datetime'].some(kw => cell.includes(kw)));
                const hasDate = lowerRow.some(cell => ['date', 'day', 'ë‚ ì§œ'].some(kw => cell.includes(kw)));
                const hasTime = lowerRow.some(cell => ['time', 'ì‹œê°„'].some(kw => cell.includes(kw)));
                const hasLat = lowerRow.some(cell => ['lat', 'latitude', 'ìœ„ë„'].some(kw => cell.includes(kw)));
                const hasLng = lowerRow.some(cell => ['lng', 'longitude', 'ê²½ë„'].some(kw => cell.includes(kw)));
                return (hasCombinedTimestamp || (hasDate && hasTime)) && hasLat && hasLng;
            }

            if (parsedData.isXlsx) {
                allData = parsedData.data;
            } else {
                const data = parsedData.data;
                const headerIndices = data.map((row, i) => isHeaderRow(row) ? i : -1).filter(i => i !== -1);

                if (headerIndices.length === 0) {
                    allData['Sheet1'] = data.filter(row => !isEmptyRow(row));
                } else {
                    for (let i = 0; i < headerIndices.length; i++) {
                        const startIndex = headerIndices[i];
                        const endIndex = (i < headerIndices.length - 1) ? headerIndices[i + 1] : data.length;
                        let sheetData = data.slice(startIndex, endIndex).filter(row => !isEmptyRow(row));
                        if (sheetData.length > 1) {
                            const sheetName = `Sheet${i + 1}`;
                            allData[sheetName] = sheetData;
                        }
                    }
                }

                if (Object.keys(allData).length === 0 && data.length > 0) {
                    allData['Sheet1'] = data.filter(row => !isEmptyRow(row));
                }
            }

            Object.values(allData).forEach(sheetData => {
                if (sheetData.length > 0) {
                    sheetData[0].forEach(header => {
                        if (header && !allColumns.includes(header)) allColumns.push(header);
                    });
                }
            });

            addGroupSelector(); // Add the first default group selector

            if (Object.keys(allData).length > 0) {
                selectedSheets.add(Object.keys(allData)[0]);
            }

            createSheetControls();
            onGroupColumnChange(); // Centralized UI refresh

            document.getElementById('status').textContent = `${Object.keys(allData).length}ê°œ ì‹œíŠ¸ ë¡œë“œ ì™„ë£Œ.`;
            console.log('--- processLoadedData ì¢…ë£Œ ---');
        }

        function switchTab(tabId) {
            activeTab = tabId;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            const tabButton = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
            if (tabButton) tabButton.classList.add('active');

            const contentId = (tabId === 'sheets') ? 'sheetControls' : 'groupControls';
            const contentElement = document.getElementById(contentId);
            if (contentElement) contentElement.classList.add('active');
        }

        // ê¸°ì¡´ ë ˆì´ì–´ë¥¼ ìƒˆë¡œìš´ ê·¸ë£¹ ê¸°ì¤€ì— ë§ê²Œ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜
        function updateExistingLayersForNewGroups(groupColumns, sourceData) {
            console.log('ê¸°ì¡´ ë ˆì´ì–´ë¥¼ ìƒˆë¡œìš´ ê·¸ë£¹ ê¸°ì¤€ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ì¤‘...');

            // ìƒˆë¡œìš´ ê·¸ë£¹ ì •ë³´ ìƒì„±
            const newGroupInfo = {};
            Object.entries(sourceData).forEach(([sheetName, sheetData]) => {
                const headers = sheetData[0];
                const groupIndices = groupColumns.map(col => headers.findIndex(h => h && h.toString() === col));

                if (groupIndices.some(i => i === -1)) return;

                sheetData.slice(1).forEach((row, index) => {
                    const groupKey = groupColumns.map((col, i) => {
                        let value = row[groupIndices[i]] || 'Unknown';

                        // Date ì»¬ëŸ¼ì¸ ê²½ìš° ì •ìˆ˜í˜•ì„ ë‚ ì§œë¡œ ë³€í™˜
                        if (col && col.toLowerCase().includes('date')) {
                            if (!isNaN(value) && Number(value) > 40000) {
                                const convertedDate = convertToKST(excelSerialDateToJSDate(Number(value)));
                                value = convertedDate.date;
                            }
                        }
                        return value;
                    }).join('|');

                    const latIndex = findColumnIndex(headers, ['lat', 'latitude', 'ìœ„ë„']);
                    const lngIndex = findColumnIndex(headers, ['lng', 'longitude', 'ê²½ë„']);

                    if (latIndex !== -1 && lngIndex !== -1) {
                        const lat = parseFloat(row[latIndex]);
                        const lng = parseFloat(row[lngIndex]);

                        if (!isNaN(lat) && !isNaN(lng)) {
                            if (!newGroupInfo[groupKey]) {
                                newGroupInfo[groupKey] = [];
                            }
                            newGroupInfo[groupKey].push({
                                lat: lat,
                                lng: lng,
                                sheetName: sheetName,
                                rowIndex: index + 2
                            });
                        }
                    }
                });
            });

            // ê¸°ì¡´ ë§ˆì»¤ë“¤ì˜ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
            Object.entries(mapLayers).forEach(([layerKey, layer]) => {
                if (layerKey.startsWith('marker_')) {
                    const markerData = layer.markerData;
                    if (markerData) {
                        const newGroupKey = findNewGroupKeyForLocation(markerData, newGroupInfo);
                        if (newGroupKey) {
                            const color = getGroupColor(newGroupKey);
                            updateMarkerColor(layer, color);
                        }
                    }
                }
            });

            // ê¸°ì¡´ ê²½ë¡œë“¤ì˜ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
            Object.entries(pathLayers).forEach(([layerKey, pathArray]) => {
                if (layerKey.startsWith('path_')) {
                    const pathData = pathArray[0]?.pathData;
                    if (pathData) {
                        const newGroupKey = findNewGroupKeyForPath(pathData, newGroupInfo);
                        if (newGroupKey) {
                            const color = getGroupColor(newGroupKey);
                            updatePathColor(pathArray, color);
                        }
                    }
                }
            });

            // ê·¸ë£¹ ì»¨íŠ¸ë¡¤ ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ìƒíƒœ ìœ ì§€)
            const hierarchicalData = buildHierarchicalData(newGroupInfo);
            createGroupControls(hierarchicalData);
        }

        // ìœ„ì¹˜ì— ëŒ€í•œ ìƒˆë¡œìš´ ê·¸ë£¹ í‚¤ ì°¾ê¸°
        function findNewGroupKeyForLocation(location, newGroupInfo) {
            const tolerance = 0.0001; // ì•½ 10ë¯¸í„°
            for (const [groupKey, locations] of Object.entries(newGroupInfo)) {
                for (const loc of locations) {
                    if (Math.abs(loc.lat - location.lat) < tolerance &&
                        Math.abs(loc.lng - location.lng) < tolerance &&
                        loc.sheetName === location.sheetName) {
                        return groupKey;
                    }
                }
            }
            return null;
        }

        // ê²½ë¡œì— ëŒ€í•œ ìƒˆë¡œìš´ ê·¸ë£¹ í‚¤ ì°¾ê¸°
        function findNewGroupKeyForPath(pathData, newGroupInfo) {
            const startGroup = findNewGroupKeyForLocation(pathData.start, newGroupInfo);
            const endGroup = findNewGroupKeyForLocation(pathData.end, newGroupInfo);

            // ì‹œì‘ì ê³¼ ëì ì´ ê°™ì€ ê·¸ë£¹ì— ìˆìœ¼ë©´ í•´ë‹¹ ê·¸ë£¹ ë°˜í™˜
            if (startGroup && startGroup === endGroup) {
                return startGroup;
            }
            return null;
        }

        // ë§ˆì»¤ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
        function updateMarkerColor(layer, color) {
            const mapApi = getMapApi();
            if (mapProvider === 'osm' && layer.marker && layer.marker.setStyle) {
                layer.marker.setStyle({ color: color });
            } else if (mapProvider === 'naver' && layer.marker) {
                // Naver Mapsì˜ ê²½ìš° ë§ˆì»¤ ìƒ‰ìƒ ë³€ê²½
                layer.marker.setIcon({
                    content: `<div style="background-color: ${color}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>`
                });
            }
        }

        // ê²½ë¡œ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
        function updatePathColor(pathArray, color) {
            const mapApi = getMapApi();
            if (mapProvider === 'osm') {
                pathArray.forEach(path => {
                    if (path.setStyle) {
                        path.setStyle({ color: color });
                    }
                });
            } else if (mapProvider === 'naver') {
                // Naver Mapsì˜ ê²½ìš° ê²½ë¡œ ìƒ‰ìƒ ë³€ê²½
                pathArray.forEach(path => {
                    if (path.setOptions) {
                        path.setOptions({ strokeColor: color });
                    }
                });
            }
        }

        // ê·¸ë£¹ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
        function getGroupColor(groupKey) {
            const groupKeys = Array.from(new Set(allLocations.map(loc => loc.group)));
            const colorIndex = groupKeys.indexOf(groupKey);
            return colors[colorIndex % colors.length];
        }

        // ê³„ì¸µì  ë°ì´í„° êµ¬ì¶•
        function buildHierarchicalData(groupInfo) {
            const hierarchicalData = {};

            Object.entries(groupInfo).forEach(([groupKey, locations]) => {
                const parts = groupKey.split('|');
                let current = hierarchicalData;

                parts.forEach((part, index) => {
                    if (!current[part]) {
                        current[part] = {
                            count: 0,
                            children: {}
                        };
                    }
                    current[part].count += locations.length;

                    if (index < parts.length - 1) {
                        current = current[part].children;
                    }
                });
            });

            return hierarchicalData;
        }

        function displayDataAsGroups(groupColumns, sourceData) {
            const mapApi = getMapApi();
            mapApi.clearAllLayers();

            const allLocations = [];
            const hierarchicalData = {};
            const displayKeyToOriginalKey = {}; // ë³€í™˜ëœ í‚¤ì™€ ì›ë˜ í‚¤ ë§¤í•‘
            let tsIndex = -1, latIndex = -1, lngIndex = -1;
            const groupIndices = groupColumns.map(() => -1);

            // 1. Consolidate all data points
            Object.values(sourceData).forEach(sheetData => {
                const headers = sheetData[0];
                tsIndex = findColumnIndex(headers, ['tslocal', 'timestamp', 'datetime']);
                const dateIndex = findColumnIndex(headers, ['date', 'day', 'ë‚ ì§œ']);
                const timeIndex = findColumnIndex(headers, ['time', 'ì‹œê°„']);
                latIndex = findColumnIndex(headers, ['lat', 'latitude', 'ìœ„ë„']);
                lngIndex = findColumnIndex(headers, ['lng', 'longitude', 'ê²½ë„']);

                const hasTimestamp = tsIndex !== -1 || (dateIndex !== -1 && timeIndex !== -1);
                if (!hasTimestamp || latIndex === -1 || lngIndex === -1) return;

                groupColumns.forEach((col, i) => {
                    groupIndices[i] = headers.findIndex(h => h && h.toString() === col);
                });

                if (groupIndices.some(i => i === -1)) return;

                sheetData.slice(1).forEach((row, index) => {
                    const groupKey = groupColumns.map((_, i) => row[groupIndices[i]] || 'Unknown').join('|');
                    let date = row[dateIndex];
                    let time = row[timeIndex];

                    if (typeof date === 'number') {
                        const kst = convertToKST(excelSerialDateToJSDate(date));
                        date = kst.date;
                    }
                    if (typeof time === 'number') {
                        const kst = convertToKST(excelSerialDateToJSDate(time));
                        time = kst.time;
                    }

                    const timestamp = tsIndex !== -1 ? row[tsIndex] : `${date} ${time}`;
                    allLocations.push({
                        timestamp: timestamp,
                        date: date,
                        time: time,
                        lat: parseFloat(row[latIndex]),
                        lng: parseFloat(row[lngIndex]),
                        group: groupKey,
                        rawData: row,
                        headers: headers,
                        rowIndex: index + 2
                    });
                });
            });

            allLocations.sort((a, b) => {
                if (tsIndex !== -1) {
                    return new Date(a.timestamp) - new Date(b.timestamp);
                }
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                if (dateA > dateB) return 1;
                if (dateA < dateB) return -1;
                return String(a.time).localeCompare(String(b.time));
            });

            // 2. Build hierarchical data and populate initial selections
            const allGroupKeys = new Set();
            allLocations.forEach(loc => {
                let currentLevel = hierarchicalData;
                const keys = loc.group.split('|');
                keys.forEach((key, i) => {
                    // Date ì»¬ëŸ¼ì¸ ê²½ìš° ë³€í™˜ëœ ê°’ìœ¼ë¡œ í‘œì‹œ
                    let displayKey = key;
                    const columnName = groupColumns[i];
                    if (columnName && columnName.toLowerCase().includes('date')) {
                        if (!isNaN(key) && Number(key) > 40000) { // Excel serial date ë²”ìœ„
                            const convertedDate = convertToKST(excelSerialDateToJSDate(Number(key)));
                            displayKey = convertedDate.date;
                        }
                    }

                    const fullKey = keys.slice(0, i + 1).join('|');
                    const displayFullKey = keys.slice(0, i).concat([displayKey]).join('|');
                    allGroupKeys.add(fullKey);
                    displayKeyToOriginalKey[displayFullKey] = fullKey;

                    if (i === keys.length - 1) {
                        if (!currentLevel[displayKey]) currentLevel[displayKey] = [];
                        currentLevel[displayKey].push(loc);
                    } else {
                        if (!currentLevel[displayKey]) currentLevel[displayKey] = {};
                        currentLevel = currentLevel[displayKey];
                    }
                });
            });

            // ì´ˆê¸° ì„ íƒëœ ê·¸ë£¹ì´ ì—†ë‹¤ë©´ ëª¨ë“  ê·¸ë£¹ ì„ íƒ
            if (selectedGroups.size === 0 && allGroupKeys.size > 0) {
                allGroupKeys.forEach(g => selectedGroups.add(g));
            }

            // 3. Filter visible locations
            const visibleLocations = allLocations.filter(loc => selectedGroups.has(loc.group));

            // 4. Draw markers
            const markerLayers = [];
            visibleLocations.forEach(loc => {
                if (isNaN(loc.lat) || isNaN(loc.lng)) return;
                const color = getColorForValue(loc.group.split('|')[0]); // Color by top-level group
                const marker = mapApi.createMarker(loc, color, loc.group);
                // ë§ˆì»¤ì— ìœ„ì¹˜ ë°ì´í„° ì €ì¥ (blinkGroup í•¨ìˆ˜ì—ì„œ ì‚¬ìš©)
                marker.locationData = loc;
                markerLayers.push(marker);
            });
            mapApi.addLayers(markerLayers);
            mapLayers['groupedMarkers'] = markerLayers;

            // 5. Path visibility logic
            if (showPaths && visibleLocations.length > 1) {
                const pathLayersArr = [];
                for (let i = 0; i < visibleLocations.length - 1; i++) {
                    const start = visibleLocations[i];
                    const end = visibleLocations[i + 1];
                    if (isNaN(start.lat) || isNaN(start.lng) || isNaN(end.lat) || isNaN(end.lng)) continue;
                    const color = getColorForValue(start.group.split('|')[0]);
                    pathLayersArr.push(...mapApi.createPath([start, end], color));
                }
                mapApi.addLayers(pathLayersArr);
                pathLayers['groupedPaths'] = pathLayersArr;
            }

            createGroupControls(hierarchicalData);
            if (visibleLocations.length > 0) {
                mapApi.fitBounds(visibleLocations);
            }
        }

        function onGroupColumnChange() {
            const newGroupColumns = Array.from(document.querySelectorAll('.group-column-selector')).map(s => s.value).filter(v => v);

            // If group columns change, reset selected groups
            if (JSON.stringify(newGroupColumns) !== JSON.stringify(currentGroupColumns)) {
                selectedGroups.clear();
            }
            currentGroupColumns = newGroupColumns;

            const mapApi = getMapApi();
            mapApi.clearAllLayers();
            mapLayers = {}; pathLayers = {}; clearPopup();

            const visibleSheetData = {};
            selectedSheets.forEach(sheetName => {
                if (allData[sheetName]) visibleSheetData[sheetName] = allData[sheetName];
            });

            if (currentGroupColumns.length > 0) {
                displayDataAsGroups(currentGroupColumns, visibleSheetData);
                switchTab('groups');
            } else {
                createGroupControls({});
                Object.entries(visibleSheetData).forEach(([sheetName, sheetData]) => {
                    const colorIndex = Object.keys(allData).indexOf(sheetName);
                    processAndDisplayData(sheetName, sheetData, colors[colorIndex % colors.length], true);
                });
                switchTab('sheets');
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('status').textContent = 'íŒŒì¼ ì²˜ë¦¬ ì¤‘...';
            const reader = new FileReader();

            if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                reader.onload = function (e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });

                        if (workbook.SheetNames.length === 0) {
                            document.getElementById('status').textContent = 'ì˜¤ë¥˜: XLSX íŒŒì¼ì— ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.';
                            return;
                        }

                        const sheetData = {};
                        workbook.SheetNames.forEach(sheetName => {
                            const worksheet = workbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                            if (jsonData.length > 0) {
                                sheetData[sheetName] = jsonData.filter(row => !isEmptyRow(row));
                            }
                        });
                        processLoadedData({ data: sheetData, isXlsx: true });
                    } catch (error) {
                        console.error('XLSX ì²˜ë¦¬ ì¤‘ ì‹¬ê°í•œ ì˜¤ë¥˜ ë°œìƒ:', error);
                        document.getElementById('status').textContent = `ì˜¤ë¥˜: XLSX íŒŒì¼ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (${error.message})`;
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                reader.onload = (e) => {
                    Papa.parse(e.target.result, {
                        header: false,
                        skipEmptyLines: true,
                        complete: (results) => {
                            if (results.errors.length > 0) {
                                console.warn('CSV íŒŒì‹± ì˜¤ë¥˜:', results.errors);
                                document.getElementById('status').textContent = `íŒŒì‹± ì˜¤ë¥˜: ${results.errors[0].message}`;
                                return;
                            }
                            processLoadedData({ data: results.data, isXlsx: false });
                        }
                    });
                };
                reader.readAsText(file, 'UTF-8');
            }
        }

        function handleUrlLoad() {
            const url = document.getElementById('sheetUrl').value;
            if (!url) return alert('êµ¬ê¸€ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');

            const match = url.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            if (!match) return alert('ìœ íš¨í•œ êµ¬ê¸€ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ URLì´ ì•„ë‹™ë‹ˆë‹¤.');

            const sheetId = match[1];
            const gidMatch = url.match(/[#&]gid=([0-9]+)/);
            const gid = gidMatch ? gidMatch[1] : '0';

            const originalUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`;
            const csvUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(originalUrl)}`;

            document.getElementById('status').textContent = 'URLì—ì„œ ë°ì´í„° ë¡œë“œ ì¤‘...';
            Papa.parse(csvUrl, {
                download: true,
                header: false,
                skipEmptyLines: true,
                complete: (results) => {
                    if (results.errors.length > 0) {
                        console.warn('CSV íŒŒì‹± ì˜¤ë¥˜:', results.errors);
                        document.getElementById('status').textContent = `íŒŒì‹± ì˜¤ë¥˜: ${results.errors[0].message}`;
                        return;
                    }
                    processLoadedData({ data: results.data, isXlsx: false });
                },
                error: (err) => {
                    document.getElementById('status').textContent = 'URL ë¡œë“œ ì˜¤ë¥˜';
                    alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. URLê³¼ ì‹œíŠ¸ ê³µìœ  ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }
            });
        }

        function toggleMapProvider() {
            const toggle = document.getElementById('mapProviderToggle');
            mapProvider = toggle.classList.contains('active') ? 'osm' : 'naver';
            toggle.classList.toggle('active');

            // ë„¤ì´ë²„ ì§€ë„ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ Client IDê°€ í•„ìš”í•©ë‹ˆë‹¤.
            const naverApiScript = document.getElementById('naverMapApi');
            if (mapProvider === 'naver' && naverApiScript.src.includes('[YOUR_CLIENT_ID_HERE]')) {
                alert('ë„¤ì´ë²„ ì§€ë„ APIë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ index.html íŒŒì¼ì—ì„œ [YOUR_CLIENT_ID_HERE]ë¥¼ ì‹¤ì œ í´ë¼ì´ì–¸íŠ¸ IDë¡œ ë³€ê²½í•´ì•¼ í•©ë‹ˆë‹¤.');
                mapProvider = 'osm';
                toggle.classList.remove('active');
                return;
            }

            // Reset layers before re-initializing the map and redrawing data
            mapLayers = {};
            pathLayers = {};

            initMap();
            onGroupColumnChange(); // ì§€ë„ ë³€ê²½ í›„ ë°ì´í„° ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        }

        document.addEventListener('DOMContentLoaded', function () {
            initMap();

            document.getElementById('csvFile').addEventListener('change', handleFileSelect);
            document.getElementById('loadFromUrl').addEventListener('click', handleUrlLoad);
            document.getElementById('addGroupLevel').addEventListener('click', () => addGroupSelector());
            document.getElementById('pathToggle').addEventListener('click', togglePaths);
            document.getElementById('mapProviderToggle').addEventListener('click', toggleMapProvider);

            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => switchTab(btn.dataset.tab));
            });
        });
    </script>
</body>

</html>